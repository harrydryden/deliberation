import { useState, useEffect, useCallback, useRef } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { productionLogger } from '@/utils/productionLogger';

interface RealtimeConnectionState {
  isConnected: boolean;
  lastActivity: number;
  reconnectAttempts: number;
  connectionError: string | null;
  totalMessages: number;
  status: 'connected' | 'disconnected' | 'reconnecting' | 'error';
}

interface RealtimeConnectionHook {
  connectionState: RealtimeConnectionState;
  forceReconnect: () => void;
  getHealthStats: () => {
    isHealthy: boolean;
    lastActivityTime: string;
    reconnectAttempts: number;
    status: string;
  };
}

export const useRealtimeConnection = (deliberationId?: string): RealtimeConnectionHook => {
  const [state, setState] = useState<RealtimeConnectionState>({
    isConnected: false,
    lastActivity: Date.now(),
    reconnectAttempts: 0,
    connectionError: null,
    totalMessages: 0,
    status: 'disconnected'
  });

  const channelRef = useRef<any>(null);
  const reconnectTimeoutRef = useRef<NodeJS.Timeout>();
  const healthCheckIntervalRef = useRef<NodeJS.Timeout>();
  const maxReconnectAttempts = 5;

  // Health check - detect stale connections
  const performHealthCheck = useCallback(() => {
    const now = Date.now();
    const timeSinceLastActivity = now - state.lastActivity;
    const staleThreshold = 600000; // 10 minutes - aligned with health check frequency
    const warnThreshold = 300000; // 5 minutes - warn but don't error

    // Warn if connection seems stale but still connected
    if (timeSinceLastActivity > warnThreshold && state.isConnected) {
      productionLogger.debug('Real-time connection has been quiet', {
        timeSinceLastActivity,
        deliberationId,
        minutesSinceLastActivity: Math.round(timeSinceLastActivity / 60000)
      });
    }

    // Only mark as error if truly disconnected AND very stale
    if (timeSinceLastActivity > staleThreshold && !state.isConnected) {
      productionLogger.warn('Real-time connection appears stale and disconnected', {
        timeSinceLastActivity,
        deliberationId,
        minutesSinceLastActivity: Math.round(timeSinceLastActivity / 60000)
      });
      
      setState(prev => ({
        ...prev,
        status: 'error',
        connectionError: 'Connection stale and disconnected'
      }));
    }
  }, [state.lastActivity, state.isConnected, deliberationId]);

  // Connect with exponential backoff and connection stability
  const connect = useCallback(() => {
    // Prevent multiple connections
    if (channelRef.current) {
      productionLogger.debug('Cleaning up existing channel before reconnect');
      supabase.removeChannel(channelRef.current);
      channelRef.current = null;
    }

    // Add debounce to prevent rapid reconnection attempts
    setState(prev => ({ 
      ...prev, 
      status: 'reconnecting',
      connectionError: null 
    }));

    try {
      const channelName = `realtime-${deliberationId || 'global'}-${Date.now()}`;
      const channel = supabase
        .channel(channelName)
        .on(
          'postgres_changes',
          {
            event: 'INSERT',
            schema: 'public',
            table: 'messages',
            filter: deliberationId ? `deliberation_id=eq.${deliberationId}` : undefined,
          },
          (payload) => {
            productionLogger.info('Real-time message received', {
              messageId: payload.new.id,
              deliberationId: payload.new.deliberation_id
            });

            setState(prev => ({
              ...prev,
              isConnected: true,
              lastActivity: Date.now(),
              reconnectAttempts: 0,
              connectionError: null,
              totalMessages: prev.totalMessages + 1,
              status: 'connected'
            }));
          }
        )
        .subscribe((status) => {
          productionLogger.info('Real-time subscription status', { status, deliberationId, channelName });
          
          if (status === 'SUBSCRIBED') {
            setState(prev => ({
              ...prev,
              isConnected: true,
              status: 'connected',
              reconnectAttempts: 0,
              connectionError: null,
              lastActivity: Date.now()
            }));
          } else if (status === 'CLOSED') {
            // Only trigger reconnect if we were previously connected
            setState(prev => {
              if (prev.isConnected) {
                productionLogger.warn('Real-time connection closed unexpectedly', { deliberationId });
                // Schedule reconnect after a longer delay
                setTimeout(() => scheduleReconnect(), 2000);
              }
              return {
                ...prev,
                isConnected: false,
                status: 'disconnected'
              };
            });
          } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT') {
            setState(prev => ({
              ...prev,
              isConnected: false,
              status: 'error',
              connectionError: `Subscription ${status.toLowerCase()}`
            }));
            scheduleReconnect();
          }
        });

      channelRef.current = channel;
    } catch (error) {
      productionLogger.error('Real-time connection failed', error);
      setState(prev => ({
        ...prev,
        isConnected: false,
        status: 'error',
        connectionError: error instanceof Error ? error.message : 'Connection failed'
      }));
      scheduleReconnect();
    }
  }, [deliberationId]);

  // Schedule reconnect with exponential backoff - prevent rapid attempts
  const scheduleReconnect = useCallback(() => {
    if (state.reconnectAttempts >= maxReconnectAttempts) {
      productionLogger.error('Max reconnection attempts reached', { deliberationId });
      setState(prev => ({
        ...prev,
        status: 'error',
        connectionError: 'Max reconnection attempts reached'
      }));
      return;
    }

    // Increased minimum delay to prevent rapid reconnects
    const delay = Math.min(5000 * Math.pow(2, state.reconnectAttempts), 60000); // Increased base delay
    
    productionLogger.info('Scheduling real-time reconnect', { 
      delay, 
      attempt: state.reconnectAttempts + 1,
      deliberationId 
    });

    setState(prev => ({
      ...prev,
      reconnectAttempts: prev.reconnectAttempts + 1
    }));

    reconnectTimeoutRef.current = setTimeout(() => {
      connect();
    }, delay);
  }, [state.reconnectAttempts, connect, deliberationId]);

  // Force reconnection
  const forceReconnect = useCallback(() => {
    productionLogger.info('Force reconnecting real-time', { deliberationId });
    
    if (reconnectTimeoutRef.current) {
      clearTimeout(reconnectTimeoutRef.current);
    }

    setState(prev => ({
      ...prev,
      reconnectAttempts: 0,
      connectionError: null
    }));

    connect();
  }, [connect, deliberationId]);

  // Get health statistics
  const getHealthStats = useCallback(() => {
    const timeSinceLastActivity = Date.now() - state.lastActivity;
    // Align healthy threshold with warning threshold (5 minutes)
    return {
      isHealthy: state.isConnected && timeSinceLastActivity < 300000, // 5 minutes
      lastActivityTime: new Date(state.lastActivity).toLocaleTimeString(),
      reconnectAttempts: state.reconnectAttempts,
      status: state.status,
      minutesSinceLastActivity: Math.round(timeSinceLastActivity / 60000)
    };
  }, [state]);

  // Initialize connection with delay to prevent immediate reconnection loops
  useEffect(() => {
    if (deliberationId) {
      // Prevent multiple simultaneous connections
      if (channelRef.current) {
        return;
      }
      
      // Add small delay to prevent rapid connection attempts
      const initTimeout = setTimeout(() => {
        connect();
      }, 500); // Increased delay
      
      // Start health check interval aligned with stale detection
      healthCheckIntervalRef.current = setInterval(performHealthCheck, 300000); // Check every 5 minutes

      return () => {
        clearTimeout(initTimeout);
        if (channelRef.current) {
          supabase.removeChannel(channelRef.current);
          channelRef.current = null;
        }
        if (reconnectTimeoutRef.current) {
          clearTimeout(reconnectTimeoutRef.current);
        }
        if (healthCheckIntervalRef.current) {
          clearInterval(healthCheckIntervalRef.current);
        }
      };
    }
  }, [deliberationId]); // Removed connect and performHealthCheck from dependencies

  return {
    connectionState: state,
    forceReconnect,
    getHealthStats
  };
};