// Unified Agent Service - Frontend integration with orchestrator
import { IAgentService } from '../interfaces';
import { IAgentRepository } from '@/repositories/interfaces';
import { Agent } from '@/types/index';
import { logger } from '@/utils/logger';
import { supabase } from '@/integrations/supabase/client';

// Cache invalidation integration for frontend
class FrontendCacheManager {
  private cacheInvalidationCallbacks: Map<string, (() => void)[]> = new Map();

  // Subscribe to cache invalidation events
  subscribeToInvalidation(eventType: string, callback: () => void): void {
    if (!this.cacheInvalidationCallbacks.has(eventType)) {
      this.cacheInvalidationCallbacks.set(eventType, []);
    }
    this.cacheInvalidationCallbacks.get(eventType)!.push(callback);
  }

  // Notify subscribers about cache invalidation
  notifyInvalidation(eventType: string): void {
    const callbacks = this.cacheInvalidationCallbacks.get(eventType) || [];
    callbacks.forEach(callback => {
      try {
        callback();
      } catch (error) {
        logger.error('Cache invalidation callback error', { error });
      }
    });
  }

  // Setup real-time listeners for agent configuration changes
  setupRealtimeInvalidation(): void {
    supabase
      .channel('frontend_agent_cache_invalidation')
      .on('postgres_changes', 
        { 
          event: '*', 
          schema: 'public', 
          table: 'agent_configurations' 
        }, 
        (payload: any) => {
          logger.info('Agent configuration changed, invalidating frontend caches', { payload });
          this.notifyInvalidation('agent_config_changed');
        }
      )
      .subscribe();

    supabase
      .channel('frontend_prompt_cache_invalidation')
      .on('postgres_changes', 
        { 
          event: '*', 
          schema: 'public', 
          table: 'prompt_templates' 
        }, 
        (payload: any) => {
          logger.info('Prompt template changed, invalidating frontend caches', { payload });
          this.notifyInvalidation('prompt_template_changed');
        }
      )
      .subscribe();
  }

  // Get cache statistics
  getCacheCallbackStats() {
    return Array.from(this.cacheInvalidationCallbacks.entries()).reduce((stats, [event, callbacks]) => {
      stats[event] = callbacks.length;
      return stats;
    }, {} as Record<string, number>);
  }
}

export class UnifiedAgentService implements IAgentService {
  private agentRepository: IAgentRepository;
  private cacheManager: FrontendCacheManager;

  constructor(agentRepository: IAgentRepository) {
    this.agentRepository = agentRepository;
    this.cacheManager = new FrontendCacheManager();
    this.setupCacheInvalidation();
  }

  private setupCacheInvalidation(): void {
    // Setup real-time invalidation
    this.cacheManager.setupRealtimeInvalidation();

    // Subscribe to invalidation events for general cache management
    this.cacheManager.subscribeToInvalidation('agent_config_changed', () => {
      logger.info('Agent configuration cache invalidated');
    });

    this.cacheManager.subscribeToInvalidation('prompt_template_changed', () => {
      logger.info('Prompt template cache invalidated');
    });
  }

  // Simple prompt preview for UI purposes (not used for actual generation)
  // Actual system prompt generation is handled by backend AgentOrchestrator
  generatePromptPreview(agent: Agent): string {
    // Check for manual override first
    if (agent.prompt_overrides?.system_prompt) {
      return agent.prompt_overrides.system_prompt;
    }

    // Simple preview generation
    let preview = `You are ${agent.name}`;
    
    if (agent.description) {
      preview += `, ${agent.description}`;
    }
    
    if (agent.goals?.length) {
      preview += `\n\nYour goals are:\n${agent.goals.map(g => `- ${g}`).join('\n')}`;
    }
    
    if (agent.response_style) {
      preview += `\n\nResponse style: ${agent.response_style}`;
    }

    preview += "\n\n[Note: Full system prompt with context enhancement is generated by backend during actual conversations]";
    
    return preview;
  }


  // ENHANCED CRUD OPERATIONS WITH CACHE INVALIDATION
  async createAgent(agent: Omit<Agent, 'id' | 'created_at' | 'updated_at'>): Promise<Agent> {
    try {
      const createdAgent = await this.agentRepository.create(agent);
      
      // Invalidate caches
      this.cacheManager.notifyInvalidation('agent_config_changed');
      
      logger.info('Agent created successfully', { 
        agentId: createdAgent.id, 
        name: createdAgent.name,
        type: createdAgent.agent_type 
      });
      
      return createdAgent;
    } catch (error) {
      logger.error('Agent service createAgent failed', { error, agentName: agent.name });
      throw error;
    }
  }

  async updateAgent(id: string, agent: Partial<Agent>): Promise<Agent> {
    try {
      const updatedAgent = await this.agentRepository.update(id, agent);
      
      // Invalidate caches
      this.cacheManager.notifyInvalidation('agent_config_changed');
      
      logger.info('Agent updated successfully', { 
        agentId: id, 
        updatedFields: Object.keys(agent) 
      });
      
      return updatedAgent;
    } catch (error) {
      logger.error('Agent service updateAgent failed', { error, agentId: id });
      throw error;
    }
  }

  async deleteAgent(id: string): Promise<void> {
    try {
      await this.agentRepository.delete(id);
      
      // Invalidate caches
      this.cacheManager.notifyInvalidation('agent_config_changed');
      
      logger.info('Agent deleted successfully', { agentId: id });
    } catch (error) {
      logger.error('Agent service deleteAgent failed', { error, agentId: id });
      throw error;
    }
  }

  // DELEGATE OTHER METHODS TO EXISTING REPOSITORY
  async getAgents(filter?: Record<string, any>): Promise<Agent[]> {
    try {
      return await this.agentRepository.findAll(filter);
    } catch (error) {
      logger.error('Agent service getAgents failed', { error, filter });
      throw error;
    }
  }

  async getLocalAgents(): Promise<Agent[]> {
    try {
      return await this.agentRepository.findLocalAgents();
    } catch (error) {
      logger.error('Agent service getLocalAgents failed', { error });
      throw error;
    }
  }

  async getGlobalAgents(): Promise<Agent[]> {
    try {
      return await this.agentRepository.findGlobalAgents();
    } catch (error) {
      logger.error('Agent service getGlobalAgents failed', { error });
      throw error;
    }
  }

  async getAgentsByDeliberation(deliberationId: string): Promise<Agent[]> {
    try {
      return await this.agentRepository.findByDeliberation(deliberationId);
    } catch (error) {
      logger.error('Agent service getAgentsByDeliberation failed', { error, deliberationId });
      throw error;
    }
  }

  // GET CACHE STATISTICS
  getCacheStats() {
    return {
      realtimeListeners: 2, // agent_configurations and prompt_templates
      cacheInvalidationCallbacks: this.cacheManager.getCacheCallbackStats()
    };
  }
}